use core::fmt::{self, Write};

use crate::parser::{LlmlParser as Parser, Rule};
use pest::iterators::Pair;

/// A syntax tree node.
pub enum Node {
    Root(Vec<Node>),
    MacroCall(String, Vec<Node>),
    Element(String, Vec<Node>),
    Attribute(String, String),
    Literal(String),
    Null,
}

impl Node {
    /// Create a new Literal node from a string.
    fn new_literal(content: &str) -> Self {
        Node::Literal(content.replace("\n", " "))
    }

    /// Create a new Literal node from a Literal rule.
    fn from_literal_rule(pair: Pair<Rule>) -> Self {
        Self::new_literal(pair.as_str())
    }

    /// Create a new Attribute node with the given key and value.
    fn new_attribute(key: &str, value: &str) -> Self {
        Self::Attribute(key.to_string(), value.to_string())
    }

    /// Create a new Attribute node from an Attribute rule.
    fn from_attribute_rule(pair: Pair<Rule>) -> Self {
        let mut ar = pair.into_inner();
        let key = ar.next().unwrap().as_str();
        let value = ar.next().unwrap().as_str();

        Self::new_attribute(key, value)
    }

    /// Create a new Attribute node from an ElementClass rule.
    fn from_element_class_rule(pair: Pair<Rule>) -> Self {
        let name = pair.as_str().replace(".", "");
        Self::new_attribute("class", &name)
    }

    /// Create a new node from an Element rule.
    fn from_element_rule(pair: Pair<Rule>) -> Self {
        let mut name = String::new();
        let mut children: Vec<Node> = vec![];

        for p in pair.into_inner() {
            if p.as_rule() == Rule::ElementName {
                name = p.as_str().to_string();
                continue;
            }

            let c = match p.as_rule() {
                Rule::ElementClass => Self::from_element_class_rule(p),
                Rule::Attribute => Self::from_attribute_rule(p),
                _ => Self::from_primary_rule(p),
            };

            children.push(c);
        }

        Node::Element(name, children)
    }

    /// Create a node from a MacroCall rule.
    fn from_macro_call_rule(pair: Pair<Rule>) -> Self {
        let mut name = String::new();
        let mut args: Vec<Node> = vec![];

        for p in pair.into_inner() {
            if p.as_rule() == Rule::MacroName {
                name = p.as_str().to_string();
            } else {
                args.push(Self::from_primary_rule(p));
            }
        }

        Node::MacroCall(name, args)
    }

    /// Create a new node from a rule. Must be a top-level rule.
    fn from_primary_rule(pair: Pair<Rule>) -> Self {
        match pair.as_rule() {
            Rule::Element => Self::from_element_rule(pair),
            Rule::MacroCall => Self::from_macro_call_rule(pair),
            Rule::Literal => Self::from_literal_rule(pair),
            Rule::EOI => Self::Null,
            _ => unreachable!(),
        }
    }

    /// Create a node tree from a File rule generated by the parser.
    pub fn from_parsed_file(pair: Pair<Rule>) -> Result<Self, String> {
        if pair.as_rule() != Rule::File {
            return Err("Recieved unexpected root rule (expected File)".to_string());
        }

        let mut children: Vec<Node> = vec![];
        for p in pair.into_inner() {
            // Top-level rules can only be elements or macros.
            let e = Self::from_primary_rule(p);
            match e {
                Self::Null => continue,
                Self::Element(ref n, _) => {
                    if n.is_empty() {
                        continue;
                    }
                }
                _ => (),
            }

            children.push(e);
        }

        Ok(Node::Root(children))
    }

    /// Create a node tree from LLML input.
    pub fn from_file_content(content: &str) -> Result<Self, String> {
        let parsed_file = Parser::parse_file_content(content)?;
        Self::from_parsed_file(parsed_file)
    }
}

/// Pretty-print a vector of AST nodes.
fn write_nodes(f: &mut fmt::Formatter, nodes: &[Node]) -> fmt::Result {
    use indenter::indented;
    let mut df = indented(f).with_str("  ");

    for (i, c) in nodes.iter().enumerate() {
        writeln!(df, "{}.{}", i, c)?;
    }

    Ok(())
}

impl fmt::Display for Node {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use self::Node::*;

        match self {
            Null => write!(f, "Null<>"),
            Literal(s) => write!(f, "Literal[{:?}],", s),
            Attribute(k, v) => write!(f, "Attribute[{}={:?}],", k, v),
            Element(n, c) => {
                writeln!(f, "Element[{}] {{", n)?;
                write_nodes(f, c)?;
                write!(f, "}},")
            }
            MacroCall(m, a) => {
                writeln!(f, "MacroCall[{}] {{", m)?;
                write_nodes(f, a)?;
                write!(f, "}},")
            }
            Root(r) => {
                writeln!(f, "Root {{")?;
                write_nodes(f, r)?;
                write!(f, "}}")
            }
        }
    }
}
