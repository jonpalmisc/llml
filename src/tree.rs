use crate::parser::{LlmlParser, Rule};
use pest::iterators::Pair;

type ChildNodes = Vec<Node>;

// AST nodes don't map 1:1 to DOM elements - but some nodes do.
pub enum Node {
    Root(ChildNodes),
    Element(String, ChildNodes),
    Attribute(String, String),
    Literal(String),
}

impl Node {
    /// Create a new Literal node from a string.
    fn new_literal(content: &str) -> Self {
        Node::Literal(content.to_string())
    }

    /// Create a new Attribute node with the given key and value.
    fn new_attribute(key: &str, value: &str) -> Self {
        Self::Attribute(key.to_string(), value.to_string())
    }

    /// Create a new node from an Element rule.
    fn from_element_rule(pair: Pair<Rule>) -> Self {
        let mut name = String::new();
        let mut children: Vec<Node> = vec![];

        for p in pair.into_inner() {
            match p.as_rule() {
                Rule::ElementName => name = p.as_str().to_string(),
                Rule::ElementClass => {
                    let class_name = p.as_str().replace(".", "");
                    children.push(Self::new_attribute("class", &class_name));
                }
                Rule::AttributeList => {
                    for i in p.into_inner() {
                        let mut a = i.into_inner();
                        let k = a.next().unwrap().as_str();
                        let v = a.next().unwrap().as_str();

                        children.push(Self::new_attribute(k, v));
                    }
                }
                Rule::Element => children.push(Self::from_element_rule(p)),
                Rule::Literal => children.push(Self::new_literal(p.as_str())),
                _ => (),
            }
        }

        Node::Element(name, children)
    }

    /// Create a node tree from a File rule generated by the parser.
    pub fn from_parsed_file(pair: Pair<Rule>) -> Self {
        if pair.as_rule() != Rule::File {
            panic!("Expected file rule");
        }

        let mut children: Vec<Node> = vec![];
        for p in pair.into_inner() {
            children.push(Self::from_element_rule(p));
        }

        Node::Root(children)
    }

    /// Create a node tree from LLML input.
    pub fn from_file_content(content: &str) -> Self {
        let parsed_file = LlmlParser::parse_file_content(content);
        Self::from_parsed_file(parsed_file)
    }

    /// Print a tree of nodes in debug format.
    pub fn print(&self, level: usize) {
        match &self {
            Self::Root(nodes) => {
                for n in nodes {
                    n.print(0);
                }
            }
            Self::Element(n, c) => {
                println!("{}Element<{}>", " ".repeat(level * 2), n);

                for d in c {
                    d.print(level + 1);
                }

                println!("");
            }
            Self::Attribute(k, v) => {
                println!("{}Attribute<{}={:?}>", " ".repeat(level * 2), k, v);
            }
            Self::Literal(s) => {
                println!("{}Literal<{:?}>", " ".repeat(level * 2), s);
            }
        }
    }
}
